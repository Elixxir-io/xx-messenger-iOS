// Objective-C API for talking to gitlab.com/elixxir/client/bindings Go package.
//   gobind -lang=objc gitlab.com/elixxir/client/bindings
//
// File is generated by gobind. Do not edit.

#ifndef __Bindings_H__
#define __Bindings_H__

@import Foundation;
#include "ref.h"
#include "Universe.objc.h"


@class BindingsBackup;
@class BindingsBackupReport;
@class BindingsClient;
@class BindingsContact;
@class BindingsContactList;
@class BindingsDummyTraffic;
@class BindingsFact;
@class BindingsFactList;
@class BindingsFilePartTracker;
@class BindingsFileTransfer;
@class BindingsGroup;
@class BindingsGroupChat;
@class BindingsGroupMember;
@class BindingsGroupMembership;
@class BindingsGroupMessageReceive;
@class BindingsGroupReportDisk;
@class BindingsGroupSendReport;
@class BindingsIdList;
@class BindingsIntList;
@class BindingsManyNotificationForMeReport;
@class BindingsMessage;
@class BindingsNewGroupReport;
@class BindingsNodeRegistrationsStatus;
@class BindingsNotificationForMeReport;
@class BindingsRestoreContactsReport;
@class BindingsRoundList;
@class BindingsSendReport;
@class BindingsSendReportDisk;
@class BindingsUnregister;
@class BindingsUser;
@class BindingsUserDiscovery;
@protocol BindingsAuthConfirmCallback;
@class BindingsAuthConfirmCallback;
@protocol BindingsAuthRequestCallback;
@class BindingsAuthRequestCallback;
@protocol BindingsAuthResetNotificationCallback;
@class BindingsAuthResetNotificationCallback;
@protocol BindingsClientError;
@class BindingsClientError;
@protocol BindingsEventCallbackFunctionObject;
@class BindingsEventCallbackFunctionObject;
@protocol BindingsFileTransferReceiveFunc;
@class BindingsFileTransferReceiveFunc;
@protocol BindingsFileTransferReceivedProgressFunc;
@class BindingsFileTransferReceivedProgressFunc;
@protocol BindingsFileTransferSentProgressFunc;
@class BindingsFileTransferSentProgressFunc;
@protocol BindingsGroupReceiveFunc;
@class BindingsGroupReceiveFunc;
@protocol BindingsGroupRequestFunc;
@class BindingsGroupRequestFunc;
@protocol BindingsListener;
@class BindingsListener;
@protocol BindingsLogWriter;
@class BindingsLogWriter;
@protocol BindingsLookupCallback;
@class BindingsLookupCallback;
@protocol BindingsMessageDeliveryCallback;
@class BindingsMessageDeliveryCallback;
@protocol BindingsMultiLookupCallback;
@class BindingsMultiLookupCallback;
@protocol BindingsNetworkHealthCallback;
@class BindingsNetworkHealthCallback;
@protocol BindingsPreimageNotification;
@class BindingsPreimageNotification;
@protocol BindingsRestoreContactsUpdater;
@class BindingsRestoreContactsUpdater;
@protocol BindingsRoundCompletionCallback;
@class BindingsRoundCompletionCallback;
@protocol BindingsRoundEventCallback;
@class BindingsRoundEventCallback;
@protocol BindingsSearchCallback;
@class BindingsSearchCallback;
@protocol BindingsSingleSearchCallback;
@class BindingsSingleSearchCallback;
@protocol BindingsTimeSource;
@class BindingsTimeSource;
@protocol BindingsUpdateBackupFunc;
@class BindingsUpdateBackupFunc;

@protocol BindingsAuthConfirmCallback <NSObject>
- (void)callback:(BindingsContact* _Nullable)partner;
@end

@protocol BindingsAuthRequestCallback <NSObject>
- (void)callback:(BindingsContact* _Nullable)requestor;
@end

@protocol BindingsAuthResetNotificationCallback <NSObject>
- (void)callback:(BindingsContact* _Nullable)requestor;
@end

@protocol BindingsClientError <NSObject>
- (void)report:(NSString* _Nullable)source message:(NSString* _Nullable)message trace:(NSString* _Nullable)trace;
@end

@protocol BindingsEventCallbackFunctionObject <NSObject>
- (void)reportEvent:(long)priority category:(NSString* _Nullable)category evtType:(NSString* _Nullable)evtType details:(NSString* _Nullable)details;
@end

@protocol BindingsFileTransferReceiveFunc <NSObject>
- (void)receiveCallback:(NSData* _Nullable)tid fileName:(NSString* _Nullable)fileName fileType:(NSString* _Nullable)fileType sender:(NSData* _Nullable)sender size:(long)size preview:(NSData* _Nullable)preview;
@end

@protocol BindingsFileTransferReceivedProgressFunc <NSObject>
- (void)receivedProgressCallback:(BOOL)completed received:(long)received total:(long)total t:(BindingsFilePartTracker* _Nullable)t err:(NSError* _Nullable)err;
@end

@protocol BindingsFileTransferSentProgressFunc <NSObject>
- (void)sentProgressCallback:(BOOL)completed sent:(long)sent arrived:(long)arrived total:(long)total t:(BindingsFilePartTracker* _Nullable)t err:(NSError* _Nullable)err;
@end

@protocol BindingsGroupReceiveFunc <NSObject>
- (void)groupReceiveCallback:(BindingsGroupMessageReceive* _Nullable)msg;
@end

@protocol BindingsGroupRequestFunc <NSObject>
- (void)groupRequestCallback:(BindingsGroup* _Nullable)g;
@end

@protocol BindingsListener <NSObject>
/**
 * Hear is called to receive a message in the UI
 */
- (void)hear:(BindingsMessage* _Nullable)message;
/**
 * Returns a name, used for debugging
 */
- (NSString* _Nonnull)name;
@end

@protocol BindingsLogWriter <NSObject>
- (void)log:(NSString* _Nullable)p0;
@end

@protocol BindingsLookupCallback <NSObject>
- (void)callback:(BindingsContact* _Nullable)contact error:(NSString* _Nullable)error;
@end

@protocol BindingsMessageDeliveryCallback <NSObject>
- (void)eventCallback:(NSData* _Nullable)msgID delivered:(BOOL)delivered timedOut:(BOOL)timedOut roundResults:(NSData* _Nullable)roundResults;
@end

@protocol BindingsMultiLookupCallback <NSObject>
- (void)callback:(BindingsContactList* _Nullable)Succeeded failed:(BindingsIdList* _Nullable)failed errors:(NSString* _Nullable)errors;
@end

@protocol BindingsNetworkHealthCallback <NSObject>
- (void)callback:(BOOL)p0;
@end

@protocol BindingsPreimageNotification <NSObject>
- (void)notify:(NSData* _Nullable)identity deleted:(BOOL)deleted;
@end

@protocol BindingsRestoreContactsUpdater <NSObject>
/**
 * RestoreContactsCallback is called to report the current # of contacts
that have been found and how many have been restored
against the total number that need to be
processed. If an error occurs it it set on the err variable as a
plain string.
 */
- (void)restoreContactsCallback:(long)numFound numRestored:(long)numRestored total:(long)total err:(NSString* _Nullable)err;
@end

@protocol BindingsRoundCompletionCallback <NSObject>
- (void)eventCallback:(long)rid success:(BOOL)success timedOut:(BOOL)timedOut;
@end

@protocol BindingsRoundEventCallback <NSObject>
- (void)eventCallback:(long)rid state:(long)state timedOut:(BOOL)timedOut;
@end

@protocol BindingsSearchCallback <NSObject>
- (void)callback:(BindingsContactList* _Nullable)contacts error:(NSString* _Nullable)error;
@end

@protocol BindingsSingleSearchCallback <NSObject>
- (void)callback:(BindingsContact* _Nullable)contact error:(NSString* _Nullable)error;
@end

@protocol BindingsTimeSource <NSObject>
- (int64_t)nowMs;
@end

@protocol BindingsUpdateBackupFunc <NSObject>
- (void)updateBackup:(NSData* _Nullable)encryptedBackup;
@end

@interface BindingsBackup : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * AddJson stores a passed in json string in the backup structure
 */
- (void)addJson:(NSString* _Nullable)json;
/**
 * IsBackupRunning returns true if the backup has been initialized and is
running. Returns false if it has been stopped.
 */
- (BOOL)isBackupRunning;
/**
 * StopBackup stops the backup processes and deletes the user's password from
storage. To enable backups again, call InitializeBackup.
 */
- (BOOL)stopBackup:(NSError* _Nullable* _Nullable)error;
@end

@interface BindingsBackupReport : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
// skipped field BackupReport.RestoredContacts with unsupported type: []*gitlab.com/xx_network/primitives/id.ID

@property (nonatomic) NSString* _Nonnull params;
@end

/**
 * BindingsClient wraps the api.Client, implementing additional functions
to support the gomobile Client interface
 */
@interface BindingsClient : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
- (BOOL)confirmAuthenticatedChannel:(NSData* _Nullable)recipientMarshaled ret0_:(long* _Nullable)ret0_ error:(NSError* _Nullable* _Nullable)error;
/**
 * DeleteAllRequests clears all requests from Client's auth storage.
 */
- (BOOL)deleteAllRequests:(NSError* _Nullable* _Nullable)error;
/**
 * DeleteContact is a function which removes a contact from Client's storage
 */
- (BOOL)deleteContact:(NSData* _Nullable)b error:(NSError* _Nullable* _Nullable)error;
/**
 * DeleteReceiveRequests clears receive requests from Client's auth storage.
 */
- (BOOL)deleteReceiveRequests:(NSError* _Nullable* _Nullable)error;
/**
 * DeleteRequest will delete a request, agnostic of request type
for the given partner ID. If no request exists for this
partner ID an error will be returned.
 */
- (BOOL)deleteRequest:(NSData* _Nullable)requesterUserId error:(NSError* _Nullable* _Nullable)error;
/**
 * DeleteSentRequests clears sent requests from Client's auth storage.
 */
- (BOOL)deleteSentRequests:(NSError* _Nullable* _Nullable)error;
// skipped method Client.GetInternalClient with unsupported parameter or return types

/**
 * GetNodeRegistrationStatus returns a struct with the number of nodes the
client is registered with and the number total.
 */
- (BindingsNodeRegistrationsStatus* _Nullable)getNodeRegistrationStatus:(NSError* _Nullable* _Nullable)error;
/**
 * GetPartners returns a list of
 */
- (NSData* _Nullable)getPartners:(NSError* _Nullable* _Nullable)error;
/**
 * GetPreferredBins returns the geographic bin or bins that the provided two
character country code is a part of. The bins are returned as CSV.
 */
- (NSString* _Nonnull)getPreferredBins:(NSString* _Nullable)countryCode error:(NSError* _Nullable* _Nullable)error;
- (NSString* _Nonnull)getPreimages:(NSData* _Nullable)identity;
// skipped method Client.GetRateLimitParams with unsupported parameter or return types

- (NSString* _Nonnull)getRelationshipFingerprint:(NSData* _Nullable)partnerID error:(NSError* _Nullable* _Nullable)error;
/**
 * Returns a user object from which all information about the current user
can be gleaned
 */
- (BindingsUser* _Nullable)getUser;
/**
 * HasRunningProcessies checks if any background threads are running.
returns true if none are running. This is meant to be
used when NetworkFollowerStatus() returns Stopping.
Due to the handling of comms on iOS, where the OS can
block indefiently, it may not enter the stopped
state apropreatly. This can be used instead.
 */
- (BOOL)hasRunningProcessies;
/**
 * returns true if the network is read to be in a healthy state where
messages can be sent
 */
- (BOOL)isNetworkHealthy;
- (BindingsContact* _Nullable)makePrecannedAuthenticatedChannel:(long)precannedID error:(NSError* _Nullable* _Nullable)error;
/**
 * Gets the state of the network follower. Returns:
Stopped 	- 0
Starting - 1000
Running	- 2000
Stopping	- 3000
 */
- (long)networkFollowerStatus;
- (void)registerAuthCallbacks:(id<BindingsAuthRequestCallback> _Nullable)request confirm:(id<BindingsAuthConfirmCallback> _Nullable)confirm reset:(id<BindingsAuthResetNotificationCallback> _Nullable)reset;
/**
 * RegisterClientErrorCallback registers the callback to handle errors from the
long running threads controlled by StartNetworkFollower and StopNetworkFollower
 */
- (void)registerClientErrorCallback:(id<BindingsClientError> _Nullable)clientError;
/**
 * RegisterEventCallback records the given function to receive
ReportableEvent objects. It returns the internal index
of the callback so that it can be deleted later.
 */
- (BOOL)registerEventCallback:(NSString* _Nullable)name myObj:(id<BindingsEventCallbackFunctionObject> _Nullable)myObj error:(NSError* _Nullable* _Nullable)error;
/**
 * RegisterForNotifications accepts firebase messaging token
 */
- (BOOL)registerForNotifications:(NSString* _Nullable)token error:(NSError* _Nullable* _Nullable)error;
/**
 * RegisterListener records and installs a listener for messages
matching specific uid, msgType, and/or username
Returns a ListenerUnregister interface which can be

to register for any userID, pass in an id with length 0 or an id with
all zeroes

to register for any message type, pass in a message type of 0

Message Types can be found in client/interfaces/message/type.go
Make sure to not conflict with ANY default message types
 */
- (BindingsUnregister* _Nullable)registerListener:(NSData* _Nullable)uid msgType:(long)msgType listener:(id<BindingsListener> _Nullable)listener error:(NSError* _Nullable* _Nullable)error;
/**
 * RegisterNetworkHealthCB registers the network health callback to be called
any time the network health changes. Returns a unique ID that can be used to
unregister the network health callback.
 */
- (int64_t)registerNetworkHealthCB:(id<BindingsNetworkHealthCallback> _Nullable)nhc;
- (void)registerPreimageCallback:(NSData* _Nullable)identity pin:(id<BindingsPreimageNotification> _Nullable)pin;
/**
 * RegisterRoundEventsHandler registers a callback interface for round
events.
The rid is the round the event attaches to
The timeoutMS is the number of milliseconds until the event fails, and the
validStates are a list of states (one per byte) on which the event gets
triggered
States:
 0x00 - PENDING (Never seen by client)
 0x01 - PRECOMPUTING
 0x02 - STANDBY
 0x03 - QUEUED
 0x04 - REALTIME
 0x05 - COMPLETED
 0x06 - FAILED
These states are defined in elixxir/primitives/states/state.go
 */
- (BindingsUnregister* _Nullable)registerRoundEventsHandler:(long)rid cb:(id<BindingsRoundEventCallback> _Nullable)cb timeoutMS:(long)timeoutMS il:(BindingsIntList* _Nullable)il;
- (void)replayRequests;
- (BOOL)requestAuthenticatedChannel:(NSData* _Nullable)recipientMarshaled meMarshaled:(NSData* _Nullable)meMarshaled message:(NSString* _Nullable)message ret0_:(long* _Nullable)ret0_ error:(NSError* _Nullable* _Nullable)error;
- (BOOL)resetSession:(NSData* _Nullable)recipientMarshaled meMarshaled:(NSData* _Nullable)meMarshaled message:(NSString* _Nullable)message ret0_:(long* _Nullable)ret0_ error:(NSError* _Nullable* _Nullable)error;
/**
 * This will return the round the message was sent on if it is successfully sent
This can be used to register a round event to learn about message delivery.
on failure a round id of -1 is returned
 */
- (BOOL)sendCmix:(NSData* _Nullable)recipient contents:(NSData* _Nullable)contents parameters:(NSString* _Nullable)parameters ret0_:(long* _Nullable)ret0_ error:(NSError* _Nullable* _Nullable)error;
/**
 * SendE2E sends an end-to-end payload to the provided recipient with
the provided msgType. Returns the list of rounds in which parts of
the message were sent or an error if it fails.

Message Types can be found in client/interfaces/message/type.go
Make sure to not conflict with ANY default message types
 */
- (BindingsSendReport* _Nullable)sendE2E:(NSData* _Nullable)recipient payload:(NSData* _Nullable)payload messageType:(long)messageType parameters:(NSString* _Nullable)parameters error:(NSError* _Nullable* _Nullable)error;
/**
 * SendUnsafe sends an unencrypted payload to the provided recipient
with the provided msgType. Returns the list of rounds in which parts
of the message were sent or an error if it fails.
NOTE: Do not use this function unless you know what you are doing.
This function always produces an error message in client logging.

Message Types can be found in client/interfaces/message/type.go
Make sure to not conflict with ANY default message types with custom types
 */
- (BindingsRoundList* _Nullable)sendUnsafe:(NSData* _Nullable)recipient payload:(NSData* _Nullable)payload messageType:(long)messageType parameters:(NSString* _Nullable)parameters error:(NSError* _Nullable* _Nullable)error;
/**
 * SetProxiedBins updates the host pool filter that filters out gateways that
are not in one of the specified bins. The provided bins should be CSV.
 */
- (BOOL)setProxiedBins:(NSString* _Nullable)binStringsCSV error:(NSError* _Nullable* _Nullable)error;
/**
 * StartNetworkFollower kicks off the tracking of the network. It starts
long running network client threads and returns an object for checking
state and stopping those threads.
Call this when returning from sleep and close when going back to
sleep.
These threads may become a significant drain on battery when offline, ensure
they are stopped if there is no internet access
Threads Started:
  - Network Follower (/network/follow.go)
  	tracks the network events and hands them off to workers for handling
  - Historical Round Retrieval (/network/rounds/historical.go)
		Retrieves data about rounds which are too old to be stored by the client
	 - Message Retrieval Worker Group (/network/rounds/retrieve.go)
		Requests all messages in a given round from the gateway of the last node
	 - Message Handling Worker Group (/network/message/handle.go)
		Decrypts and partitions messages when signals via the Switchboard
	 - Health Tracker (/network/health)
		Via the network instance tracks the state of the network
	 - Garbled Messages (/network/message/garbled.go)
		Can be signaled to check all recent messages which could be be decoded
		Uses a message store on disk for persistence
	 - Critical Messages (/network/message/critical.go)
		Ensures all protocol layer mandatory messages are sent
		Uses a message store on disk for persistence
	 - KeyExchange Trigger (/keyExchange/trigger.go)
		Responds to sent rekeys and executes them
  - KeyExchange Confirm (/keyExchange/confirm.go)
		Responds to confirmations of successful rekey operations
 */
- (BOOL)startNetworkFollower:(long)timeoutMS error:(NSError* _Nullable* _Nullable)error;
/**
 * StopNetworkFollower stops the network follower if it is running.
It returns errors if the Follower is in the wrong status to stop or if it
fails to stop it.
if the network follower is running and this fails, the client object will
most likely be in an unrecoverable state and need to be trashed.
 */
- (BOOL)stopNetworkFollower:(NSError* _Nullable* _Nullable)error;
/**
 * UnregisterEventCallback deletes the callback identified by the
index. It returns an error if it fails.
 */
- (void)unregisterEventCallback:(NSString* _Nullable)name;
/**
 * UnregisterForNotifications unregister user for notifications
 */
- (BOOL)unregisterForNotifications:(NSError* _Nullable* _Nullable)error;
- (void)unregisterNetworkHealthCB:(int64_t)funcID;
- (BOOL)verifyOwnership:(NSData* _Nullable)receivedMarshaled verifiedMarshaled:(NSData* _Nullable)verifiedMarshaled ret0_:(BOOL* _Nullable)ret0_ error:(NSError* _Nullable* _Nullable)error;
/**
 * WaitForMessageDelivery allows the caller to get notified if the rounds a
message was sent in successfully completed. Under the hood, this uses an API
which uses the internal round data, network historical round lookup, and
waiting on network events to determine what has (or will) occur.

The callbacks will return at timeoutMS if no state update occurs

This function takes the marshaled send report to ensure a memory leak does
not occur as a result of both sides of the bindings holding a reference to
the same pointer.
 */
- (BOOL)waitForMessageDelivery:(NSData* _Nullable)marshaledSendReport mdc:(id<BindingsMessageDeliveryCallback> _Nullable)mdc timeoutMS:(long)timeoutMS error:(NSError* _Nullable* _Nullable)error;
/**
 * WaitForNewtwork will block until either the network is healthy or the
passed timeout. It will return true if the network is healthy
 */
- (BOOL)waitForNetwork:(long)timeoutMS;
/**
 * WaitForRoundCompletion allows the caller to get notified if a round
has completed (or failed). Under the hood, this uses an API which uses the internal
round data, network historical round lookup, and waiting on network events
to determine what has (or will) occur.

The callbacks will return at timeoutMS if no state update occurs
 */
- (BOOL)waitForRoundCompletion:(long)roundID rec:(id<BindingsRoundCompletionCallback> _Nullable)rec timeoutMS:(long)timeoutMS error:(NSError* _Nullable* _Nullable)error;
@end

/**
 *  contact object
 */
@interface BindingsContact : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
// skipped method Contact.GetAPIContact with unsupported parameter or return types

/**
 * GetDHPublicKey returns the public key associated with the Contact.
 */
- (NSData* _Nullable)getDHPublicKey;
/**
 * Returns a fact list for adding and getting facts to and from the contact
 */
- (BindingsFactList* _Nullable)getFactList;
/**
 * GetID returns the user ID for this user.
 */
- (NSData* _Nullable)getID;
/**
 * GetDHPublicKey returns hash of a DH proof of key ownership.
 */
- (NSData* _Nullable)getOwnershipProof;
- (NSData* _Nullable)marshal:(NSError* _Nullable* _Nullable)error;
@end

@interface BindingsContactList : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * Gets a stored round ID at the given index
 */
- (BindingsContact* _Nullable)get:(long)i error:(NSError* _Nullable* _Nullable)error;
/**
 * Gets the number of round IDs stored
 */
- (long)len;
@end

/**
 * DummyTraffic contains the file dummy traffic manager. The manager can be used
to set and get the status of the send thread.
 */
@interface BindingsDummyTraffic : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * NewDummyTrafficManager creates a DummyTraffic manager and initialises the
dummy traffic send thread. Note that the manager does not start sending dummy
traffic until its status is set to true using DummyTraffic.SetStatus.
The maxNumMessages is the upper bound of the random number of messages sent
each send. avgSendDeltaMS is the average duration, in milliseconds, to wait
between sends. Sends occur every avgSendDeltaMS +/- a random duration with an
upper bound of randomRangeMS.
 */
- (nullable instancetype)initManager:(BindingsClient* _Nullable)client maxNumMessages:(long)maxNumMessages avgSendDeltaMS:(long)avgSendDeltaMS randomRangeMS:(long)randomRangeMS;
/**
 * GetStatus returns the current state of the dummy traffic send thread. It has
the following return values:
 true  = send thread is sending dummy messages
 false = send thread is paused/stopped and not sending dummy messages
Note that this function does not return the status set by SetStatus directly;
it returns the current status of the send thread, which means any call to
SetStatus will have a small delay before it is returned by GetStatus.
 */
- (BOOL)getStatus;
/**
 * SetStatus sets the state of the dummy traffic send thread, which determines
if the thread is running or paused. The possible statuses are:
 true  = send thread is sending dummy messages
 false = send thread is paused/stopped and not sending dummy messages
Returns an error if the channel is full.
Note that this function cannot change the status of the send thread if it has
yet to be started or stopped.
 */
- (BOOL)setStatus:(BOOL)status error:(NSError* _Nullable* _Nullable)error;
@end

@interface BindingsFact : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 *  fact object
creates a new fact. The factType must be either:
 0 - Username
 1 - Email
 2 - Phone Number
The fact must be well formed for the type and must not include commas or
semicolons. If it is not well formed, it will be rejected.  Phone numbers
must have the two letter country codes appended.  For the complete set of
validation, see /elixxir/primitives/fact/fact.go
 */
- (nullable instancetype)init:(long)factType factStr:(NSString* _Nullable)factStr;
- (NSString* _Nonnull)get;
- (NSString* _Nonnull)stringify;
- (long)type;
@end

@interface BindingsFactList : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * FactList
 */
- (nullable instancetype)init;
- (BOOL)add:(NSString* _Nullable)factData factType:(long)factType error:(NSError* _Nullable* _Nullable)error;
- (BindingsFact* _Nullable)get:(long)i;
- (long)num;
- (NSString* _Nonnull)stringify:(NSError* _Nullable* _Nullable)error;
@end

/**
 * FilePartTracker contains the interfaces.FilePartTracker.
 */
@interface BindingsFilePartTracker : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * GetNumParts returns the total number of file parts in the transfer.
 */
- (long)getNumParts;
/**
 * GetPartStatus returns the status of the file part with the given part number.
The possible values for the status are:
0 = unsent
1 = sent (sender has sent a part, but it has not arrived)
2 = arrived (sender has sent a part, and it has arrived)
3 = received (receiver has received a part)
 */
- (long)getPartStatus:(long)partNum;
@end

/**
 * FileTransfer contains the file transfer manager.
 */
@interface BindingsFileTransfer : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * NewFileTransferManager creates a new file transfer manager and starts the
sending and receiving threads. The receiveFunc is called everytime a new file
transfer is received.
The parameters string contains file transfer network configuration options
and is a JSON formatted string of the fileTransfer.Params object. If it is
left empty, then defaults are used. It is highly recommended that defaults
are used. If it is set, it must match the following format:
 {"MaxThroughput":150000,"SendTimeout":500000000}
MaxThroughput is in bytes/sec and SendTimeout is in nanoseconds.
 */
- (nullable instancetype)initManager:(BindingsClient* _Nullable)client receiveFunc:(id<BindingsFileTransferReceiveFunc> _Nullable)receiveFunc parameters:(NSString* _Nullable)parameters;
/**
 * CloseSend deletes a sent file transfer from the sent transfer map and from
storage once a transfer has completed or reached the retry limit. Returns an
error if the transfer has not run out of retries.
 */
- (BOOL)closeSend:(NSData* _Nullable)transferID error:(NSError* _Nullable* _Nullable)error;
/**
 * GetMaxFileNameByteLength returns the maximum length, in bytes, allowed for a
file name.
 */
- (long)getMaxFileNameByteLength;
/**
 * GetMaxFilePreviewSize returns the maximum file preview size, in bytes.
 */
- (long)getMaxFilePreviewSize;
/**
 * GetMaxFileSize returns the maximum file size, in bytes, allowed to be
transferred.
 */
- (long)getMaxFileSize;
/**
 * GetMaxFileTypeByteLength returns the maximum length, in bytes, allowed for a
file type.
 */
- (long)getMaxFileTypeByteLength;
/**
 * Receive returns the fully assembled file on the completion of the transfer.
It deletes the transfer from the received transfer map and from storage.
Returns an error if the transfer is not complete, the full file cannot be
verified, or if the transfer cannot be found.
 */
- (NSData* _Nullable)receive:(NSData* _Nullable)transferID error:(NSError* _Nullable* _Nullable)error;
/**
 * RegisterReceiveProgressCallback allows for the registration of a callback to
track the progress of an individual received file transfer. The callback will
be called immediately when added to report the current status of the
transfer. It will then call every time a file part is received, the transfer
completes, or an error occurs. It is called at most once ever period, which
means if events occur faster than the period, then they will not be reported
and instead, the progress will be reported once at the end of the period.
Once the callback reports that the transfer has completed, the recipient
can get the full file by calling Receive.
The period is specified in milliseconds.
 */
- (BOOL)registerReceiveProgressCallback:(NSData* _Nullable)transferID progressFunc:(id<BindingsFileTransferReceivedProgressFunc> _Nullable)progressFunc periodMS:(long)periodMS error:(NSError* _Nullable* _Nullable)error;
/**
 * RegisterSendProgressCallback allows for the registration of a callback to
track the progress of an individual sent file transfer. The callback will be
called immediately when added to report the current status of the transfer.
It will then call every time a file part is sent, a file part arrives, the
transfer completes, or an error occurs. It is called at most once every
period, which means if events occur faster than the period, then they will
not be reported and instead, the progress will be reported once at the end of
the period.
The period is specified in milliseconds.
 */
- (BOOL)registerSendProgressCallback:(NSData* _Nullable)transferID progressFunc:(id<BindingsFileTransferSentProgressFunc> _Nullable)progressFunc periodMS:(long)periodMS error:(NSError* _Nullable* _Nullable)error;
/**
 * Send sends a file to the recipient. The sender must have an E2E relationship
with the recipient.
The file name is the name of the file to show a user. It has a max length of
48 bytes.
The file type identifies what type of file is being sent. It has a max length
of 8 bytes.
The file data cannot be larger than 256 kB
The retry float is the total amount of data to send relative to the data
size. Data will be resent on error and will resend up to [(1 + retry) *
fileSize].
The preview stores a preview of the data (such as a thumbnail) and is
capped at 4 kB in size.
Returns a unique transfer ID used to identify the transfer.
PeriodMS is the duration, in milliseconds, to wait between progress callback
calls. Set this large enough to prevent spamming.
 */
- (NSData* _Nullable)send:(NSString* _Nullable)fileName fileType:(NSString* _Nullable)fileType fileData:(NSData* _Nullable)fileData recipientID:(NSData* _Nullable)recipientID retry:(float)retry preview:(NSData* _Nullable)preview progressFunc:(id<BindingsFileTransferSentProgressFunc> _Nullable)progressFunc periodMS:(long)periodMS error:(NSError* _Nullable* _Nullable)error;
@end

/**
 * Group structure contains the identifying and membership information of a
group chat.
 */
@interface BindingsGroup : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * GetCreatedMS returns the time the group was created in milliseconds. This is
also the time the group requests were sent.
 */
- (int64_t)getCreatedMS;
/**
 * GetCreatedNano returns the time the group was created in nanoseconds. This is
also the time the group requests were sent.
 */
- (int64_t)getCreatedNano;
/**
 * GetID return the 33-byte unique group ID.
 */
- (NSData* _Nullable)getID;
/**
 * GetInitMessage returns initial message sent with the group request.
 */
- (NSData* _Nullable)getInitMessage;
/**
 * GetMembership returns a list of contacts, one for each member in the group.
The list is in order; the first contact is the leader/creator of the group.
All subsequent members are ordered by their ID.
 */
- (BindingsGroupMembership* _Nullable)getMembership;
/**
 * GetName returns the name set by the user for the group.
 */
- (NSData* _Nullable)getName;
/**
 * Serialize serializes the Group.
 */
- (NSData* _Nullable)serialize;
@end

/**
 * GroupChat object contains the group chat manager.
 */
@interface BindingsGroupChat : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * GetGroup returns the group with the group ID. If no group exists, then the
error "failed to find group" is returned.
 */
- (BindingsGroup* _Nullable)getGroup:(NSData* _Nullable)groupIdBytes error:(NSError* _Nullable* _Nullable)error;
/**
 * GetGroups returns an IdList containing a list of group IDs that the user is a
part of.
 */
- (BindingsIdList* _Nullable)getGroups;
/**
 * JoinGroup allows a user to join a group when they receive a request. The
caller must pass in the serialized bytes of a Group.
 */
- (BOOL)joinGroup:(NSData* _Nullable)serializedGroupData error:(NSError* _Nullable* _Nullable)error;
/**
 * LeaveGroup deletes a group so a user no longer has access.
 */
- (BOOL)leaveGroup:(NSData* _Nullable)groupIdBytes error:(NSError* _Nullable* _Nullable)error;
/**
 * MakeGroup creates a new group and sends a group request to all members in the
group. The ID of the new group, the rounds the requests were sent on, and the
status of the send are contained in NewGroupReport.
 */
- (BindingsNewGroupReport* _Nullable)makeGroup:(BindingsIdList* _Nullable)membership name:(NSData* _Nullable)name message:(NSData* _Nullable)message;
/**
 * NumGroups returns the number of groups the user is a part of.
 */
- (long)numGroups;
/**
 * ResendRequest resends a group request to all members in the group. The rounds
they were sent on and the status of the send are contained in NewGroupReport.
 */
- (BindingsNewGroupReport* _Nullable)resendRequest:(NSData* _Nullable)groupIdBytes error:(NSError* _Nullable* _Nullable)error;
/**
 * Send sends the message to the specified group. Returns the round the messages
were sent on.
 */
- (BindingsGroupSendReport* _Nullable)send:(NSData* _Nullable)groupIdBytes message:(NSData* _Nullable)message error:(NSError* _Nullable* _Nullable)error;
@end

/**
 * //
Member Structure
//
GroupMember represents a member in the group membership list.
 */
@interface BindingsGroupMember : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
// skipped field GroupMember.Member with unsupported type: gitlab.com/elixxir/crypto/group.Member

// skipped method GroupMember.DeepCopy with unsupported parameter or return types

// skipped method GroupMember.Equal with unsupported parameter or return types

/**
 * GetDhKey returns the byte representation of the public Diffie–Hellman key of
the member.
 */
- (NSData* _Nullable)getDhKey;
/**
 * GetID returns the 33-byte user ID of the member.
 */
- (NSData* _Nullable)getID;
- (NSString* _Nonnull)goString;
- (NSData* _Nullable)serialize;
- (NSString* _Nonnull)string;
@end

/**
 * GroupMembership structure contains a list of members that are part of a
group. The first member is the group leader.
 */
@interface BindingsGroupMembership : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * Get returns the member at the index. The member at index 0 is always the
group leader. An error is returned if the index is out of range.
 */
- (BindingsGroupMember* _Nullable)get:(long)i error:(NSError* _Nullable* _Nullable)error;
/**
 * Len returns the number of members in the group membership.
 */
- (long)len;
@end

/**
 * GroupMessageReceive contains a group message, its ID, and its data that a
user receives.
 */
@interface BindingsGroupMessageReceive : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
// skipped field GroupMessageReceive.MessageReceive with unsupported type: gitlab.com/elixxir/client/groupChat.MessageReceive

/**
 * GetEphemeralID returns the ephemeral ID of the recipient.
 */
- (int64_t)getEphemeralID;
/**
 * GetGroupID returns the 33-byte group ID.
 */
- (NSData* _Nullable)getGroupID;
/**
 * GetMessageID returns the message ID.
 */
- (NSData* _Nullable)getMessageID;
/**
 * GetPayload returns the message payload.
 */
- (NSData* _Nullable)getPayload;
/**
 * GetRecipientID returns the 33-byte user ID of the recipient.
 */
- (NSData* _Nullable)getRecipientID;
/**
 * GetRoundID returns the ID of the round the message was sent on.
 */
- (int64_t)getRoundID;
/**
 * GetRoundTimestampMS returns the timestamp, in milliseconds, of the round the
message was sent on.
 */
- (int64_t)getRoundTimestampMS;
/**
 * GetRoundTimestampNano returns the timestamp, in nanoseconds, of the round the
message was sent on.
 */
- (int64_t)getRoundTimestampNano;
/**
 * GetRoundURL returns the ID of the round the message was sent on.
 */
- (NSString* _Nonnull)getRoundURL;
/**
 * GetSenderID returns the 33-byte user ID of the sender.
 */
- (NSData* _Nullable)getSenderID;
/**
 * GetTimestampMS returns the message timestamp in milliseconds.
 */
- (int64_t)getTimestampMS;
/**
 * GetTimestampNano returns the message timestamp in nanoseconds.
 */
- (int64_t)getTimestampNano;
- (NSString* _Nonnull)string;
@end

@interface BindingsGroupReportDisk : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
// skipped field GroupReportDisk.List with unsupported type: []gitlab.com/xx_network/primitives/id.Round

@property (nonatomic) NSData* _Nullable grpId;
@property (nonatomic) long status;
@end

/**
 * GroupSendReport is returned when sending a group message. It contains the
round ID sent on and the timestamp of the send.
 */
@interface BindingsGroupSendReport : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * GetMessageID returns the ID of the round that the send occurred on.
 */
- (NSData* _Nullable)getMessageID;
/**
 * GetRoundID returns the ID of the round that the send occurred on.
 */
- (int64_t)getRoundID;
/**
 * GetRoundURL returns the URL of the round that the send occurred on.
 */
- (NSString* _Nonnull)getRoundURL;
/**
 * GetTimestampMS returns the timestamp of the send in milliseconds.
 */
- (int64_t)getTimestampMS;
/**
 * GetTimestampNano returns the timestamp of the send in nanoseconds.
 */
- (int64_t)getTimestampNano;
@end

/**
 *  ID list
IdList contains a list of IDs.
 */
@interface BindingsIdList : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * Add appends the ID bytes to the end of the list.
 */
- (BOOL)add:(NSData* _Nullable)idBytes error:(NSError* _Nullable* _Nullable)error;
/**
 * Get returns the ID at the index. An error is returned if the index is out of
range.
 */
- (NSData* _Nullable)get:(long)i error:(NSError* _Nullable* _Nullable)error;
/**
 * Len returns the number of IDs in the list.
 */
- (long)len;
@end

@interface BindingsIntList : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
- (void)add:(long)i;
- (BOOL)get:(long)i ret0_:(long* _Nullable)ret0_ error:(NSError* _Nullable* _Nullable)error;
- (long)len;
@end

@interface BindingsManyNotificationForMeReport : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
- (BindingsNotificationForMeReport* _Nullable)get:(long)i error:(NSError* _Nullable* _Nullable)error;
- (long)len;
@end

/**
 * Message is a message received from the cMix network in the clear
or that has been decrypted using established E2E keys.
 */
@interface BindingsMessage : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * GetID returns the id of the message
 */
- (NSData* _Nullable)getID;
/**
 * GetMessageType returns the message's type
 */
- (long)getMessageType;
/**
 * GetPayload returns the message's payload/contents
 */
- (NSData* _Nullable)getPayload;
/**
 * GetRoundId returns the message's round ID
 */
- (int64_t)getRoundId;
/**
 * GetRoundTimestampMS returns the message's round timestamp in milliseconds
 */
- (int64_t)getRoundTimestampMS;
/**
 * GetRoundTimestampNano returns the message's round timestamp in nanoseconds
 */
- (int64_t)getRoundTimestampNano;
/**
 * GetRoundURL returns the message's round URL
 */
- (NSString* _Nonnull)getRoundURL;
/**
 * GetSender returns the message's sender ID, if available
 */
- (NSData* _Nullable)getSender;
/**
 * GetTimestampMS returns the message's timestamp in milliseconds
 */
- (int64_t)getTimestampMS;
/**
 * GetTimestampNano returns the message's timestamp in nanoseconds
 */
- (int64_t)getTimestampNano;
@end

/**
 * NewGroupReport is returned when creating a new group and contains the ID of
the group, a list of rounds that the group requests were sent on, and the
status of the send.
 */
@interface BindingsNewGroupReport : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * GetError returns the string of an error.
Will be an empty string if no error occured
 */
- (NSString* _Nonnull)getError;
/**
 * GetGroup returns the Group.
 */
- (BindingsGroup* _Nullable)getGroup;
/**
 * GetRoundList returns the RoundList containing a list of rounds requests were
sent on.
 */
- (BindingsRoundList* _Nullable)getRoundList;
/**
 * GetStatus returns the status of the requests sent when creating a new group.
status = 0   an error occurred before any requests could be sent
         1   all requests failed to send (call Resend Group)
         2   some request failed and some succeeded (call Resend Group)
         3,  all requests sent successfully (call Resend Group)
 */
- (long)getStatus;
- (NSData* _Nullable)marshal:(NSError* _Nullable* _Nullable)error;
- (BOOL)unmarshal:(NSData* _Nullable)b error:(NSError* _Nullable* _Nullable)error;
@end

/**
 * NodeRegistrationsStatus structure for returning node registration statuses
for bindings.
 */
@interface BindingsNodeRegistrationsStatus : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * GetRegistered returns the number of nodes registered with the client.
 */
- (long)getRegistered;
/**
 * GetTotal return the total of nodes currently in the network.
 */
- (long)getTotal;
@end

@interface BindingsNotificationForMeReport : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
- (BOOL)forMe;
- (NSData* _Nullable)source;
- (NSString* _Nonnull)type;
@end

/**
 * RestoreContactsReport is a gomobile friendly report structure
for determining which IDs restored, which failed, and why.
 */
@interface BindingsRestoreContactsReport : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * GetErrorAt returns the error string at index
 */
- (NSString* _Nonnull)getErrorAt:(long)index;
/**
 * GetFailedAt returns the failed ID at index
 */
- (NSData* _Nullable)getFailedAt:(long)index;
/**
 * GetRestoreContactsError returns an error string. Empty if no error.
 */
- (NSString* _Nonnull)getRestoreContactsError;
/**
 * GetRestoredAt returns the restored ID at index
 */
- (NSData* _Nullable)getRestoredAt:(long)index;
/**
 * LenFailed returns the length of the ID's failed.
 */
- (long)lenFailed;
/**
 * LenRestored returns the length of ID's restored.
 */
- (long)lenRestored;
@end

@interface BindingsRoundList : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * Gets a stored round ID at the given index
 */
- (BOOL)get:(long)i ret0_:(long* _Nullable)ret0_ error:(NSError* _Nullable* _Nullable)error;
/**
 * Gets the number of round IDs stored
 */
- (long)len;
@end

/**
 * the send report is the mechanisim by which sendE2E returns a single
 */
@interface BindingsSendReport : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
- (NSData* _Nullable)getMessageID;
- (BindingsRoundList* _Nullable)getRoundList;
- (NSString* _Nonnull)getRoundURL;
/**
 * GetTimestampMS returns the message's timestamp in milliseconds
 */
- (int64_t)getTimestampMS;
/**
 * GetTimestampNano returns the message's timestamp in nanoseconds
 */
- (int64_t)getTimestampNano;
- (NSData* _Nullable)marshal:(NSError* _Nullable* _Nullable)error;
- (BOOL)unmarshal:(NSData* _Nullable)b error:(NSError* _Nullable* _Nullable)error;
@end

@interface BindingsSendReportDisk : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
// skipped field SendReportDisk.List with unsupported type: []gitlab.com/xx_network/primitives/id.Round

@property (nonatomic) NSData* _Nullable mid;
@property (nonatomic) int64_t ts;
@end

/**
 * Generic Unregister - a generic return used for all callbacks which can be
unregistered
Interface which allows the un-registration of a listener
 */
@interface BindingsUnregister : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
/**
 * Call unregisters a callback
 */
- (void)unregister;
@end

@interface BindingsUser : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (nonnull instancetype)init;
- (BindingsContact* _Nullable)getContact;
- (NSData* _Nullable)getE2EDhPrivateKey;
- (NSData* _Nullable)getE2EDhPublicKey;
- (NSData* _Nullable)getReceptionID;
- (NSData* _Nullable)getReceptionRSAPrivateKeyPem;
- (NSData* _Nullable)getReceptionRSAPublicKeyPem;
- (NSData* _Nullable)getReceptionSalt;
- (NSData* _Nullable)getTransmissionID;
- (NSData* _Nullable)getTransmissionRSAPrivateKeyPem;
- (NSData* _Nullable)getTransmissionRSAPublicKeyPem;
- (NSData* _Nullable)getTransmissionSalt;
- (BOOL)isPrecanned;
@end

@interface BindingsUserDiscovery : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * NewUserDiscovery returns a new user discovery object. Only call this once. It must be called
after StartNetworkFollower is called and will fail if the network has never
been contacted.
This function technically has a memory leak because it causes both sides of
the bindings to think the other is in charge of the client object.
In general this is not an issue because the client object should exist
for the life of the program.
This must be called while start network follower is running.
 */
- (nullable instancetype)init:(BindingsClient* _Nullable)client;
/**
 * NewUserDiscoveryFromBackup returns a new user discovery object. It
wil set up the manager with the backup data. Pass into it the backed up
facts, one email and phone number each. This will add the registered facts
to the backed Store. Any one of these fields may be empty,
however both fields being empty will cause an error. Any other fact that is not
an email or phone number will return an error. You may only add a fact for the
accepted types once each. If you attempt to back up a fact type that has already
been backed up, an error will be returned. Anytime an error is returned, it means
the backup was not successful.
NOTE: Do not use this as a direct store operation. This feature is intended to add facts
to a backend store that have ALREADY BEEN REGISTERED on the account.
THIS IS NOT FOR ADDING NEWLY REGISTERED FACTS. That is handled on the backend.
Only call this once. It must be called after StartNetworkFollower
is called and will fail if the network has never been contacted.
This function technically has a memory leak because it causes both sides of
the bindings to think the other is in charge of the client object.
In general this is not an issue because the client object should exist
for the life of the program.
This must be called while start network follower is running.
 */
- (nullable instancetype)initFromBackup:(BindingsClient* _Nullable)client email:(NSString* _Nullable)email phone:(NSString* _Nullable)phone;
/**
 * AddFact adds a fact for the user to user discovery. Will only succeed if the
user is already registered and the system does not have the fact currently
registered for any user.
Will fail if the fact string is not well formed.
This does not complete the fact registration process, it returns a
confirmation id instead. Over the communications system the fact is
associated with, a code will be sent. This confirmation ID needs to be
called along with the code to finalize the fact.
 */
- (NSString* _Nonnull)addFact:(NSString* _Nullable)fStr error:(NSError* _Nullable* _Nullable)error;
/**
 * ConfirmFact confirms a fact first registered via AddFact. The confirmation ID comes from
AddFact while the code will come over the associated communications system
 */
- (BOOL)confirmFact:(NSString* _Nullable)confirmationID code:(NSString* _Nullable)code error:(NSError* _Nullable* _Nullable)error;
/**
 * Lookup the contact object associated with the given userID.  The
id is the byte representation of an id.
This will reject if that id is malformed. The LookupCallback will return
the associated contact if it exists.
 */
- (BOOL)lookup:(NSData* _Nullable)idBytes callback:(id<BindingsLookupCallback> _Nullable)callback timeoutMS:(long)timeoutMS error:(NSError* _Nullable* _Nullable)error;
/**
 * MultiLookup Looks for the contact object associated with all given userIDs.
The ids are the byte representation of an id stored in an IDList object.
This will reject if that id is malformed or if the indexing on the IDList
object is wrong. The MultiLookupCallback will return with all contacts
returned within the timeout.
 */
- (BOOL)multiLookup:(BindingsIdList* _Nullable)ids callback:(id<BindingsMultiLookupCallback> _Nullable)callback timeoutMS:(long)timeoutMS error:(NSError* _Nullable* _Nullable)error;
/**
 * Register registers a user with user discovery. Will return an error if the
network signatures are malformed or if the username is taken. Usernames
cannot be changed after registration at this time. Will fail if the user is
already registered.
Identity does not go over cmix, it occurs over normal communications
 */
- (BOOL)register:(NSString* _Nullable)username error:(NSError* _Nullable* _Nullable)error;
/**
 * RemoveFact removes a previously confirmed fact.  Will fail if the passed fact string is
not well-formed or if the fact is not associated with this client.
Users cannot remove username facts and must instead remove the user.
 */
- (BOOL)removeFact:(NSString* _Nullable)fStr error:(NSError* _Nullable* _Nullable)error;
/**
 * RemoveUser deletes a user. The fact sent must be the username.
This function preserves the username forever and makes it
unusable.
 */
- (BOOL)removeUser:(NSString* _Nullable)fStr error:(NSError* _Nullable* _Nullable)error;
/**
 * Search for the passed Facts.  The factList is the stringification of a
fact list object, look at /bindings/list.go for more on that object.
This will reject if that object is malformed. The SearchCallback will return
a list of contacts, each having the facts it hit against.
This is NOT intended to be used to search for multiple users at once, that
can have a privacy reduction. Instead, it is intended to be used to search
for a user where multiple pieces of information is known.
 */
- (BOOL)search:(NSString* _Nullable)fl callback:(id<BindingsSearchCallback> _Nullable)callback timeoutMS:(long)timeoutMS error:(NSError* _Nullable* _Nullable)error;
/**
 * SearchSingle searches for the passed Facts.  The fact is the stringification of a
fact object, look at /bindings/contact.go for more on that object.
This will reject if that object is malformed. The SearchCallback will return
a list of contacts, each having the facts it hit against.
This only searches for a single fact at a time. It is intended to make some
simple use cases of the API easier.
 */
- (BOOL)searchSingle:(NSString* _Nullable)f callback:(id<BindingsSingleSearchCallback> _Nullable)callback timeoutMS:(long)timeoutMS error:(NSError* _Nullable* _Nullable)error;
/**
 * SetAlternativeUserDiscovery sets the alternativeUd object within manager.
Once set, any user discovery operation will go through the alternative
user discovery service.
To undo this operation, use UnsetAlternativeUserDiscovery.
The contact file is the already read in bytes, not the file path for the contact file.
 */
- (BOOL)setAlternativeUserDiscovery:(NSData* _Nullable)address cert:(NSData* _Nullable)cert contactFile:(NSData* _Nullable)contactFile error:(NSError* _Nullable* _Nullable)error;
/**
 * UnsetAlternativeUserDiscovery clears out the information from
the Manager object.
 */
- (BOOL)unsetAlternativeUserDiscovery:(NSError* _Nullable* _Nullable)error;
@end

/**
 * Error codes
 */
FOUNDATION_EXPORT NSString* _Nonnull const BindingsUnrecognizedCode;
FOUNDATION_EXPORT NSString* _Nonnull const BindingsUnrecognizedMessage;

/**
 * CompressJpeg takes a JPEG image in byte format
and compresses it based on desired output size
 */
FOUNDATION_EXPORT NSData* _Nullable BindingsCompressJpeg(NSData* _Nullable imgBytes, NSError* _Nullable* _Nullable error);

/**
 * CompressJpegForPreview takes a JPEG image in byte format
and compresses it based on desired output size
 */
FOUNDATION_EXPORT NSData* _Nullable BindingsCompressJpegForPreview(NSData* _Nullable imgBytes, NSError* _Nullable* _Nullable error);

/**
 * DownloadAndVerifySignedNdfWithUrl retrieves the NDF from a specified URL.
The NDF is processed into a protobuf containing a signature which
is verified using the cert string passed in. The NDF is returned as marshaled
byte data which may be used to start a client.
 */
FOUNDATION_EXPORT NSData* _Nullable BindingsDownloadAndVerifySignedNdfWithUrl(NSString* _Nullable url, NSString* _Nullable cert, NSError* _Nullable* _Nullable error);

/**
 * DownloadDAppRegistrationDB returns a []byte containing
the JSON data describing registered dApps.
See https://git.xx.network/elixxir/registered-dapps
 */
FOUNDATION_EXPORT NSData* _Nullable BindingsDownloadDAppRegistrationDB(NSError* _Nullable* _Nullable error);

/**
 * DownloadErrorDB returns a []byte containing the JSON data
describing client errors.
See https://git.xx.network/elixxir/client-error-database/
 */
FOUNDATION_EXPORT NSData* _Nullable BindingsDownloadErrorDB(NSError* _Nullable* _Nullable error);

/**
 * DumpStack returns a string with the stack trace of every running thread.
 */
FOUNDATION_EXPORT NSString* _Nonnull BindingsDumpStack(NSError* _Nullable* _Nullable error);

/**
 * EnableGrpcLogs sets GRPC trace logging
 */
FOUNDATION_EXPORT void BindingsEnableGrpcLogs(id<BindingsLogWriter> _Nullable writer);

/**
 * ErrorStringToUserFriendlyMessage takes a passed in errStr which will be
a backend generated error. These may be error specifically written by
the backend team or lower level errors gotten from low level dependencies.
This function will parse the error string for common errors provided from
errToUserErr to provide a more user-friendly error message for the front end.
If the error is not common, some simple parsing is done on the error message
to make it more user-accessible, removing backend specific jargon.
 */
FOUNDATION_EXPORT NSString* _Nonnull BindingsErrorStringToUserFriendlyMessage(NSString* _Nullable errStr);

/**
 * GenerateSecret creates a secret password using a system-based
pseudorandom number generator. It takes 1 parameter, `numBytes`,
which should be set to 32, but can be set higher in certain cases.
 */
FOUNDATION_EXPORT NSData* _Nullable BindingsGenerateSecret(long numBytes);

FOUNDATION_EXPORT NSString* _Nonnull BindingsGetCMIXParams(NSError* _Nullable* _Nullable error);

/**
 * returns a previously created client. IF be used if the garbage collector
removes the client instance on the app side.  Is NOT thread safe relative to
login, newClient, or newPrecannedClient
 */
FOUNDATION_EXPORT BindingsClient* _Nullable BindingsGetClientSingleton(void);

/**
 * GetDependencies returns the api DEPENDENCIES
 */
FOUNDATION_EXPORT NSString* _Nonnull BindingsGetDependencies(void);

FOUNDATION_EXPORT NSString* _Nonnull BindingsGetE2EParams(NSError* _Nullable* _Nullable error);

/**
 * GetGitVersion rturns the api GITVERSION
 */
FOUNDATION_EXPORT NSString* _Nonnull BindingsGetGitVersion(void);

FOUNDATION_EXPORT NSString* _Nonnull BindingsGetNetworkParams(NSError* _Nullable* _Nullable error);

FOUNDATION_EXPORT NSString* _Nonnull BindingsGetUnsafeParams(NSError* _Nullable* _Nullable error);

/**
 * GetVersion returns the api SEMVER
 */
FOUNDATION_EXPORT NSString* _Nonnull BindingsGetVersion(void);

/**
 * InitializeBackup starts the backup processes that returns backup updates when
they occur. Any time an event occurs that changes the contents of the backup,
such as adding or deleting a contact, the backup is triggered and an
encrypted backup is generated and returned on the updateBackupCb callback.
Call this function only when enabling backup if it has not already been
initialized or when the user wants to change their password.
To resume backup process on app recovery, use ResumeBackup.
 */
FOUNDATION_EXPORT BindingsBackup* _Nullable BindingsInitializeBackup(NSString* _Nullable password, id<BindingsUpdateBackupFunc> _Nullable updateBackupCb, BindingsClient* _Nullable c, NSError* _Nullable* _Nullable error);

/**
 * LoadSecretWithMnemonic loads the secret stored from the call to
StoreSecretWithMnemonic. The path given should be the same filepath
as the path given in StoreSecretWithMnemonic. There should be a file
in this path called ".recovery". This operation is not tied
to client operations, as the user will not have a client when trying to
recover their account.
 */
FOUNDATION_EXPORT NSData* _Nullable BindingsLoadSecretWithMnemonic(NSString* _Nullable mnemonic, NSString* _Nullable path, NSError* _Nullable* _Nullable error);

/**
 * sets level of logging. All logs the set level and above will be displayed
options are:
	TRACE		- 0
	DEBUG		- 1
	INFO 		- 2
	WARN		- 3
	ERROR		- 4
	CRITICAL	- 5
	FATAL		- 6
The default state without updates is: INFO
 */
FOUNDATION_EXPORT BOOL BindingsLogLevel(long level, NSError* _Nullable* _Nullable error);

/**
 * Login will load an existing client from the storageDir
using the password. This will fail if the client doesn't exist or
the password is incorrect.
The password is passed as a byte array so that it can be cleared from
memory and stored as securely as possible using the memguard library.
Login does not block on network connection, and instead loads and
starts subprocesses to perform network operations.
 */
FOUNDATION_EXPORT BindingsClient* _Nullable BindingsLogin(NSString* _Nullable storageDir, NSData* _Nullable password, NSString* _Nullable parameters, NSError* _Nullable* _Nullable error);

/**
 * MakeIdList creates a new empty IdList.
 */
FOUNDATION_EXPORT BindingsIdList* _Nullable BindingsMakeIdList(void);

FOUNDATION_EXPORT BindingsIntList* _Nullable BindingsMakeIntList(void);

/**
 * NewClient creates client storage, generates keys, connects, and registers
with the network. Note that this does not register a username/identity, but
merely creates a new cryptographic identity for adding such information
at a later date.

Users of this function should delete the storage directory on error.
 */
FOUNDATION_EXPORT BOOL BindingsNewClient(NSString* _Nullable network, NSString* _Nullable storageDir, NSData* _Nullable password, NSString* _Nullable regCode, NSError* _Nullable* _Nullable error);

/**
 * NewClientFromBackup constructs a new Client from an encrypted backup. The backup
is decrypted using the backupPassphrase. On success a successful client creation,
the function will return a JSON encoded list of the E2E partners
contained in the backup and a json-encoded string of the parameters stored in the backup
 */
FOUNDATION_EXPORT NSData* _Nullable BindingsNewClientFromBackup(NSString* _Nullable ndfJSON, NSString* _Nullable storageDir, NSData* _Nullable sessionPassword, NSData* _Nullable backupPassphrase, NSData* _Nullable backupFileContents, NSError* _Nullable* _Nullable error);

/**
 * NewDummyTrafficManager creates a DummyTraffic manager and initialises the
dummy traffic send thread. Note that the manager does not start sending dummy
traffic until its status is set to true using DummyTraffic.SetStatus.
The maxNumMessages is the upper bound of the random number of messages sent
each send. avgSendDeltaMS is the average duration, in milliseconds, to wait
between sends. Sends occur every avgSendDeltaMS +/- a random duration with an
upper bound of randomRangeMS.
 */
FOUNDATION_EXPORT BindingsDummyTraffic* _Nullable BindingsNewDummyTrafficManager(BindingsClient* _Nullable client, long maxNumMessages, long avgSendDeltaMS, long randomRangeMS, NSError* _Nullable* _Nullable error);

/**
 *  fact object
creates a new fact. The factType must be either:
 0 - Username
 1 - Email
 2 - Phone Number
The fact must be well formed for the type and must not include commas or
semicolons. If it is not well formed, it will be rejected.  Phone numbers
must have the two letter country codes appended.  For the complete set of
validation, see /elixxir/primitives/fact/fact.go
 */
FOUNDATION_EXPORT BindingsFact* _Nullable BindingsNewFact(long factType, NSString* _Nullable factStr, NSError* _Nullable* _Nullable error);

/**
 * FactList
 */
FOUNDATION_EXPORT BindingsFactList* _Nullable BindingsNewFactList(void);

/**
 * NewFileTransferManager creates a new file transfer manager and starts the
sending and receiving threads. The receiveFunc is called everytime a new file
transfer is received.
The parameters string contains file transfer network configuration options
and is a JSON formatted string of the fileTransfer.Params object. If it is
left empty, then defaults are used. It is highly recommended that defaults
are used. If it is set, it must match the following format:
 {"MaxThroughput":150000,"SendTimeout":500000000}
MaxThroughput is in bytes/sec and SendTimeout is in nanoseconds.
 */
FOUNDATION_EXPORT BindingsFileTransfer* _Nullable BindingsNewFileTransferManager(BindingsClient* _Nullable client, id<BindingsFileTransferReceiveFunc> _Nullable receiveFunc, NSString* _Nullable parameters, NSError* _Nullable* _Nullable error);

/**
 * NewGroupManager creates a new group chat manager.
 */
FOUNDATION_EXPORT BindingsGroupChat* _Nullable BindingsNewGroupManager(BindingsClient* _Nullable client, id<BindingsGroupRequestFunc> _Nullable requestFunc, id<BindingsGroupReceiveFunc> _Nullable receiveFunc, NSError* _Nullable* _Nullable error);

/**
 * NewPrecannedClient creates an insecure user with predetermined keys with nodes
It creates client storage, generates keys, connects, and registers
with the network. Note that this does not register a username/identity, but
merely creates a new cryptographic identity for adding such information
at a later date.

Users of this function should delete the storage directory on error.
 */
FOUNDATION_EXPORT BOOL BindingsNewPrecannedClient(long precannedID, NSString* _Nullable network, NSString* _Nullable storageDir, NSData* _Nullable password, NSError* _Nullable* _Nullable error);

/**
 * NewUserDiscovery returns a new user discovery object. Only call this once. It must be called
after StartNetworkFollower is called and will fail if the network has never
been contacted.
This function technically has a memory leak because it causes both sides of
the bindings to think the other is in charge of the client object.
In general this is not an issue because the client object should exist
for the life of the program.
This must be called while start network follower is running.
 */
FOUNDATION_EXPORT BindingsUserDiscovery* _Nullable BindingsNewUserDiscovery(BindingsClient* _Nullable client, NSError* _Nullable* _Nullable error);

/**
 * NewUserDiscoveryFromBackup returns a new user discovery object. It
wil set up the manager with the backup data. Pass into it the backed up
facts, one email and phone number each. This will add the registered facts
to the backed Store. Any one of these fields may be empty,
however both fields being empty will cause an error. Any other fact that is not
an email or phone number will return an error. You may only add a fact for the
accepted types once each. If you attempt to back up a fact type that has already
been backed up, an error will be returned. Anytime an error is returned, it means
the backup was not successful.
NOTE: Do not use this as a direct store operation. This feature is intended to add facts
to a backend store that have ALREADY BEEN REGISTERED on the account.
THIS IS NOT FOR ADDING NEWLY REGISTERED FACTS. That is handled on the backend.
Only call this once. It must be called after StartNetworkFollower
is called and will fail if the network has never been contacted.
This function technically has a memory leak because it causes both sides of
the bindings to think the other is in charge of the client object.
In general this is not an issue because the client object should exist
for the life of the program.
This must be called while start network follower is running.
 */
FOUNDATION_EXPORT BindingsUserDiscovery* _Nullable BindingsNewUserDiscoveryFromBackup(BindingsClient* _Nullable client, NSString* _Nullable email, NSString* _Nullable phone, NSError* _Nullable* _Nullable error);

/**
 * NotificationsForMe Check if a notification received is for me
It returns a NotificationForMeReport which contains a ForMe bool stating if it is for the caller,
a Type, and a source. These are as follows:
	TYPE       	SOURCE				DESCRIPTION
	"default"	recipient user ID	A message with no association
	"request"	sender user ID		A channel request has been received
	"reset"	    sender user ID		A channel reset has been received
	"confirm"	sender user ID		A channel request has been accepted
	"silent"	sender user ID		A message which should not be notified on
	"e2e"		sender user ID		reception of an E2E message
	"group"		group ID			reception of a group chat message
 "endFT"     sender user ID		Last message sent confirming end of file transfer
 "groupRQ"   sender user ID		Request from sender to join a group chat
 */
FOUNDATION_EXPORT BindingsManyNotificationForMeReport* _Nullable BindingsNotificationsForMe(NSString* _Nullable notifCSV, NSString* _Nullable preimages, NSError* _Nullable* _Nullable error);

/**
 * RegisterLogWriter registers a callback on which logs are written.
 */
FOUNDATION_EXPORT void BindingsRegisterLogWriter(id<BindingsLogWriter> _Nullable writer);

/**
 * RestoreContactsFromBackup takes as input the jason output of the
`NewClientFromBackup` function, unmarshals it into IDs, looks up
each ID in user discovery, and initiates a session reset request.
This function will not return until every id in the list has been sent a
request. It should be called again and again until it completes.
xxDK users should not use this function. This function is used by
the mobile phone apps and are not intended to be part of the xxDK. It
should be treated as internal functions specific to the phone apps.
 */
FOUNDATION_EXPORT BindingsRestoreContactsReport* _Nullable BindingsRestoreContactsFromBackup(NSData* _Nullable backupPartnerIDs, BindingsClient* _Nullable client, BindingsUserDiscovery* _Nullable udManager, id<BindingsLookupCallback> _Nullable lookupCB, id<BindingsRestoreContactsUpdater> _Nullable updatesCb);

/**
 * ResumeBackup starts the backup processes back up with a new callback after it
has been initialized.
Call this function only when resuming a backup that has already been
initialized or to replace the callback.
To start the backup for the first time or to use a new password, use
InitializeBackup.
 */
FOUNDATION_EXPORT BindingsBackup* _Nullable BindingsResumeBackup(id<BindingsUpdateBackupFunc> _Nullable cb, BindingsClient* _Nullable c, NSError* _Nullable* _Nullable error);

/**
 * SetTimeSource sets the network time to a custom source.
 */
FOUNDATION_EXPORT void BindingsSetTimeSource(id<BindingsTimeSource> _Nullable timeNow);

/**
 * StoreSecretWithMnemonic stores the secret tied with the mnemonic to storage.
Unlike other storage operations, this does not use EKV, as that is
intrinsically tied to client operations, which the user will not have while
trying to recover their account. As such, we store the encrypted data
directly, with a specified path. Path will be a valid filepath in which the
recover file will be stored as ".recovery".

As an example, given "home/user/xxmessenger/storagePath",
the recovery file will be stored at
"home/user/xxmessenger/storagePath/.recovery"
 */
FOUNDATION_EXPORT NSString* _Nonnull BindingsStoreSecretWithMnemonic(NSData* _Nullable secret, NSString* _Nullable path, NSError* _Nullable* _Nullable error);

/**
 * Unmarshals a marshaled contact object, returns an error if it fails
 */
FOUNDATION_EXPORT BindingsContact* _Nullable BindingsUnmarshalContact(NSData* _Nullable b, NSError* _Nullable* _Nullable error);

/**
 * Unmarshals a marshaled send report object, returns an error if it fails
 */
FOUNDATION_EXPORT BindingsSendReport* _Nullable BindingsUnmarshalSendReport(NSData* _Nullable b, NSError* _Nullable* _Nullable error);

/**
 * UpdateCommonErrors takes the passed in contents of a JSON file and updates the
errToUserErr map with the contents of the json file. The JSON's expected format
conform with the commented examples provides in errToUserErr above.
NOTE that you should not pass in a file path, but a preloaded JSON file
 */
FOUNDATION_EXPORT BOOL BindingsUpdateCommonErrors(NSString* _Nullable jsonFile, NSError* _Nullable* _Nullable error);

// skipped function WrapAPIClient with unsupported parameter or return types


// skipped function WrapUserDiscovery with unsupported parameter or return types


@class BindingsAuthConfirmCallback;

@class BindingsAuthRequestCallback;

@class BindingsAuthResetNotificationCallback;

@class BindingsClientError;

@class BindingsEventCallbackFunctionObject;

@class BindingsFileTransferReceiveFunc;

@class BindingsFileTransferReceivedProgressFunc;

@class BindingsFileTransferSentProgressFunc;

@class BindingsGroupReceiveFunc;

@class BindingsGroupRequestFunc;

@class BindingsListener;

@class BindingsLogWriter;

@class BindingsLookupCallback;

@class BindingsMessageDeliveryCallback;

@class BindingsMultiLookupCallback;

@class BindingsNetworkHealthCallback;

@class BindingsPreimageNotification;

@class BindingsRestoreContactsUpdater;

@class BindingsRoundCompletionCallback;

@class BindingsRoundEventCallback;

@class BindingsSearchCallback;

@class BindingsSingleSearchCallback;

@class BindingsTimeSource;

@class BindingsUpdateBackupFunc;

/**
 * AuthConfirmCallback notifies the register whenever they receive an auth
request confirmation
 */
@interface BindingsAuthConfirmCallback : NSObject <goSeqRefInterface, BindingsAuthConfirmCallback> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)callback:(BindingsContact* _Nullable)partner;
@end

/**
 * AuthRequestCallback notifies the register whenever they receive an auth
request
 */
@interface BindingsAuthRequestCallback : NSObject <goSeqRefInterface, BindingsAuthRequestCallback> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)callback:(BindingsContact* _Nullable)requestor;
@end

/**
 * AuthRequestCallback notifies the register whenever they receive an auth
request
 */
@interface BindingsAuthResetNotificationCallback : NSObject <goSeqRefInterface, BindingsAuthResetNotificationCallback> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)callback:(BindingsContact* _Nullable)requestor;
@end

@interface BindingsClientError : NSObject <goSeqRefInterface, BindingsClientError> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)report:(NSString* _Nullable)source message:(NSString* _Nullable)message trace:(NSString* _Nullable)trace;
@end

/**
 * EventCallbackFunctionObject bindings interface which contains function
that implements the EventCallbackFunction
 */
@interface BindingsEventCallbackFunctionObject : NSObject <goSeqRefInterface, BindingsEventCallbackFunctionObject> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)reportEvent:(long)priority category:(NSString* _Nullable)category evtType:(NSString* _Nullable)evtType details:(NSString* _Nullable)details;
@end

/**
 * FileTransferReceiveFunc contains a function callback that notifies the
receiver of an incoming file transfer. It is called on the reception of the
initial file transfer message.
 */
@interface BindingsFileTransferReceiveFunc : NSObject <goSeqRefInterface, BindingsFileTransferReceiveFunc> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)receiveCallback:(NSData* _Nullable)tid fileName:(NSString* _Nullable)fileName fileType:(NSString* _Nullable)fileType sender:(NSData* _Nullable)sender size:(long)size preview:(NSData* _Nullable)preview;
@end

/**
 * FileTransferReceivedProgressFunc contains a function callback that tracks the
progress of receiving a file. It is called when a file part is received, the
transfer completes, or on error.
 */
@interface BindingsFileTransferReceivedProgressFunc : NSObject <goSeqRefInterface, BindingsFileTransferReceivedProgressFunc> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)receivedProgressCallback:(BOOL)completed received:(long)received total:(long)total t:(BindingsFilePartTracker* _Nullable)t err:(NSError* _Nullable)err;
@end

/**
 * FileTransferSentProgressFunc contains a function callback that tracks the
progress of sending a file. It is called when a file part is sent, a file
part arrives, the transfer completes, or on error.
 */
@interface BindingsFileTransferSentProgressFunc : NSObject <goSeqRefInterface, BindingsFileTransferSentProgressFunc> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)sentProgressCallback:(BOOL)completed sent:(long)sent arrived:(long)arrived total:(long)total t:(BindingsFilePartTracker* _Nullable)t err:(NSError* _Nullable)err;
@end

/**
 * GroupReceiveFunc contains a function callback that is called when a group
message is received.
 */
@interface BindingsGroupReceiveFunc : NSObject <goSeqRefInterface, BindingsGroupReceiveFunc> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)groupReceiveCallback:(BindingsGroupMessageReceive* _Nullable)msg;
@end

/**
 * GroupRequestFunc contains a function callback that is called when a group
request is received.
 */
@interface BindingsGroupRequestFunc : NSObject <goSeqRefInterface, BindingsGroupRequestFunc> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)groupRequestCallback:(BindingsGroup* _Nullable)g;
@end

/**
 * Listener provides a callback to hear a message
An object implementing this interface can be called back when the client
gets a message of the type that the registerer specified at registration
time.
 */
@interface BindingsListener : NSObject <goSeqRefInterface, BindingsListener> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * Hear is called to receive a message in the UI
 */
- (void)hear:(BindingsMessage* _Nullable)message;
/**
 * Returns a name, used for debugging
 */
- (NSString* _Nonnull)name;
@end

@interface BindingsLogWriter : NSObject <goSeqRefInterface, BindingsLogWriter> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)log:(NSString* _Nullable)p0;
@end

/**
 * LookupCallback returns the result of a single lookup
 */
@interface BindingsLookupCallback : NSObject <goSeqRefInterface, BindingsLookupCallback> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)callback:(BindingsContact* _Nullable)contact error:(NSString* _Nullable)error;
@end

/**
 * MessageDeliveryCallback gets called on the determination if all events
related to a message send were successful.
 */
@interface BindingsMessageDeliveryCallback : NSObject <goSeqRefInterface, BindingsMessageDeliveryCallback> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)eventCallback:(NSData* _Nullable)msgID delivered:(BOOL)delivered timedOut:(BOOL)timedOut roundResults:(NSData* _Nullable)roundResults;
@end

/**
 * MultiLookupCallback returns the result of many parallel lookups
 */
@interface BindingsMultiLookupCallback : NSObject <goSeqRefInterface, BindingsMultiLookupCallback> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)callback:(BindingsContactList* _Nullable)Succeeded failed:(BindingsIdList* _Nullable)failed errors:(NSString* _Nullable)errors;
@end

/**
 * A callback when which is used to receive notification if network health
changes
 */
@interface BindingsNetworkHealthCallback : NSObject <goSeqRefInterface, BindingsNetworkHealthCallback> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)callback:(BOOL)p0;
@end

@interface BindingsPreimageNotification : NSObject <goSeqRefInterface, BindingsPreimageNotification> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)notify:(NSData* _Nullable)identity deleted:(BOOL)deleted;
@end

/**
 * RestoreContactsUpdater interface provides a callback function
for receiving update information from RestoreContactsFromBackup.
 */
@interface BindingsRestoreContactsUpdater : NSObject <goSeqRefInterface, BindingsRestoreContactsUpdater> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
/**
 * RestoreContactsCallback is called to report the current # of contacts
that have been found and how many have been restored
against the total number that need to be
processed. If an error occurs it it set on the err variable as a
plain string.
 */
- (void)restoreContactsCallback:(long)numFound numRestored:(long)numRestored total:(long)total err:(NSString* _Nullable)err;
@end

/**
 * RoundCompletionCallback is returned when the completion of a round is known.
 */
@interface BindingsRoundCompletionCallback : NSObject <goSeqRefInterface, BindingsRoundCompletionCallback> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)eventCallback:(long)rid success:(BOOL)success timedOut:(BOOL)timedOut;
@end

/**
 * RoundEventCallback handles waiting on the exact state of a round on
the cMix network.
 */
@interface BindingsRoundEventCallback : NSObject <goSeqRefInterface, BindingsRoundEventCallback> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)eventCallback:(long)rid state:(long)state timedOut:(BOOL)timedOut;
@end

/**
 * SearchCallback returns the result of a search
 */
@interface BindingsSearchCallback : NSObject <goSeqRefInterface, BindingsSearchCallback> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)callback:(BindingsContactList* _Nullable)contacts error:(NSString* _Nullable)error;
@end

/**
 * SingleSearchCallback returns the result of a single search
 */
@interface BindingsSingleSearchCallback : NSObject <goSeqRefInterface, BindingsSingleSearchCallback> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)callback:(BindingsContact* _Nullable)contact error:(NSString* _Nullable)error;
@end

@interface BindingsTimeSource : NSObject <goSeqRefInterface, BindingsTimeSource> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (int64_t)nowMs;
@end

/**
 * UpdateBackupFunc contains a function callback that returns new backups.
 */
@interface BindingsUpdateBackupFunc : NSObject <goSeqRefInterface, BindingsUpdateBackupFunc> {
}
@property(strong, readonly) _Nonnull id _ref;

- (nonnull instancetype)initWithRef:(_Nonnull id)ref;
- (void)updateBackup:(NSData* _Nullable)encryptedBackup;
@end

#endif
